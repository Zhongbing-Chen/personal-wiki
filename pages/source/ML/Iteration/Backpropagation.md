This article is about the computer algorithm. For the biological process, see [neural backpropagation](https://en.wikipedia.org/wiki/Neural_backpropagation "Neural backpropagation").

Backpropagation can also refer to the way the result of a playout is propagated up the search tree in [Monte Carlo tree search](https://en.wikipedia.org/wiki/Monte_Carlo_tree_search#Principle_of_operation "Monte Carlo tree search").

As a [machine-learning](https://en.wikipedia.org/wiki/Machine-learning "Machine-learning") [algorithm](https://en.wikipedia.org/wiki/Algorithm "Algorithm"), **backpropagation** performs a backward pass to adjust a neural network model's parameters, aiming to minimize the [mean squared error](https://en.wikipedia.org/wiki/Mean_squared_error "Mean squared error") (MSE).<sup id="cite_ref-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-1">[1]</a></sup><sup id="cite_ref-arxiv_2-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-arxiv-2">[2]</a></sup> In a multi-layered network, backpropagation uses the following steps:

1.  Propagate training data through the model from input to predicted output by computing the successive hidden layers' outputs and finally the final layer's output ([the feedforward step](https://en.wikipedia.org/wiki/Feedforward_neural_network "Feedforward neural network")).
2.  Adjust the model weights to reduce the error relative to the weights.
    1.  The error is typically the squared difference between prediction and target.
    2.  For each weight, the slope or derivative of the error is found, and the weight adjusted by a negative multiple of this derivative, so as to go downslope toward the minimum-error configuration.
    3.  This derivative is easy to calculate for final layer weights, and possible to calculate for one layer given the next layer's derivatives. Starting at the end, then, the derivatives are calculated layer by layer toward the beginning -- thus "backpropagation".
3.  Repeatedly update the weights until they converge or the model has undergone enough iterations.

It is an efficient application of the [Leibniz](https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz "Gottfried Wilhelm Leibniz") [chain rule](https://en.wikipedia.org/wiki/Chain_rule "Chain rule") (1673)<sup id="cite_ref-leibniz1676_3-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-leibniz1676-3">[3]</a></sup> to such networks.<sup id="cite_ref-DLhistory_4-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> It is also known as the reverse mode of [automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation "Automatic differentiation") or [reverse accumulation](https://en.wikipedia.org/wiki/Reverse_accumulation "Reverse accumulation"), due to [Seppo Linnainmaa](https://en.wikipedia.org/wiki/Seppo_Linnainmaa "Seppo Linnainmaa") (1970).<sup id="cite_ref-lin1970_5-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-lin1970-5">[5]</a></sup><sup id="cite_ref-lin1976_6-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-lin1976-6">[6]</a></sup><sup id="cite_ref-grie2012_7-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-grie2012-7">[7]</a></sup><sup id="cite_ref-grie2008_8-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-grie2008-8">[8]</a></sup><sup id="cite_ref-schmidhuber2015_9-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-schmidhuber2015-9">[9]</a></sup><sup id="cite_ref-scholarpedia2015_10-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-scholarpedia2015-10">[10]</a></sup><sup id="cite_ref-DL-reverse-mode_11-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DL-reverse-mode-11">[11]</a></sup> The term "back-propagating error correction" was introduced in 1962 by [Frank Rosenblatt](https://en.wikipedia.org/wiki/Frank_Rosenblatt "Frank Rosenblatt"),<sup id="cite_ref-12"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-12">[12]</a></sup><sup id="cite_ref-DLhistory_4-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> but he did not know how to implement this, even though [Henry J. Kelley](https://en.wikipedia.org/wiki/Henry_J._Kelley "Henry J. Kelley") had a continuous precursor of backpropagation<sup id="cite_ref-kelley1960_13-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-kelley1960-13">[13]</a></sup> already in 1960 in the context of [control theory](https://en.wikipedia.org/wiki/Control_theory "Control theory").<sup id="cite_ref-DLhistory_4-2"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup>

Backpropagation computes the [gradient](https://en.wikipedia.org/wiki/Gradient "Gradient") of a [loss function](https://en.wikipedia.org/wiki/Loss_function "Loss function") with respect to the [weights](https://en.wikipedia.org/wiki/Glossary_of_graph_theory_terms#weight "Glossary of graph theory terms") of the network for a single input–output example, and does so [efficiently](https://en.wikipedia.org/wiki/Algorithmic_efficiency "Algorithmic efficiency"), computing the gradient one layer at a time, [iterating](https://en.wikipedia.org/wiki/Iteration "Iteration") backward from the last layer to avoid redundant calculations of intermediate terms in the chain rule; this can be derived through [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming "Dynamic programming").<sup id="cite_ref-kelley1960_13-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-kelley1960-13">[13]</a></sup><sup id="cite_ref-bryson1961_14-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-bryson1961-14">[14]</a></sup><sup id="cite_ref-FOOTNOTEGoodfellowBengioCourville2016[httpswwwdeeplearningbookorgcontentsmlphtmlpf33_214]_15-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-FOOTNOTEGoodfellowBengioCourville2016[httpswwwdeeplearningbookorgcontentsmlphtmlpf33_214]-15">[15]</a></sup> [Gradient descent](https://en.wikipedia.org/wiki/Gradient_descent "Gradient descent"), or variants such as [stochastic gradient descent](https://en.wikipedia.org/wiki/Stochastic_gradient_descent "Stochastic gradient descent"),<sup id="cite_ref-robbins1951_16-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-robbins1951-16">[16]</a></sup> are commonly used.

Strictly the term _backpropagation_ refers only to the algorithm for computing the gradient, not how the gradient is used; but the term is often used loosely to refer to the entire learning algorithm – including how the gradient is used, such as by stochastic gradient descent.<sup id="cite_ref-17"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-17">[17]</a></sup> In 1986 [David E. Rumelhart](https://en.wikipedia.org/wiki/David_E._Rumelhart "David E. Rumelhart") et al. published an experimental analysis of the technique.<sup id="cite_ref-learning-representations_18-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-learning-representations-18">[18]</a></sup> This contributed to the popularization of backpropagation and helped to initiate an active period of research in [multilayer perceptrons](https://en.wikipedia.org/wiki/Multilayer_perceptron "Multilayer perceptron").

## Overview\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=1 "Edit section: Overview")\]

Backpropagation computes the gradient in [weight space](https://en.wikipedia.org/wiki/Parameter_space "Parameter space") of a feedforward neural network, with respect to a [loss function](https://en.wikipedia.org/wiki/Loss_function "Loss function"). Denote:

-   ![x](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4): input (vector of features)
-   ![y](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d): target output
    
    For classification, output will be a vector of class probabilities (e.g., ![{\displaystyle (0.1,0.7,0.2)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/fbb2f54392fb76b6dea26425e24447bf2c48cc94), and target output is a specific class, encoded by the [one-hot](https://en.wikipedia.org/wiki/One-hot "One-hot")/[dummy variable](https://en.wikipedia.org/wiki/Dummy_variable_(statistics) "Dummy variable (statistics)") (e.g., ![(0,1,0)](https://wikimedia.org/api/rest_v1/media/math/render/svg/3e28bfe8a44d06939011e3ba2159e894c0f22f23)).
    
-   ![C](https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029): [loss function](https://en.wikipedia.org/wiki/Loss_function "Loss function") or "cost function"<sup id="cite_ref-19"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-19">[a]</a></sup>
    
    For classification, this is usually [cross-entropy](https://en.wikipedia.org/wiki/Cross-entropy "Cross-entropy") (XC, [log loss](https://en.wikipedia.org/wiki/Log_loss "Log loss")), while for regression it is usually [squared error loss](https://en.wikipedia.org/wiki/Squared_error_loss "Squared error loss") (SEL).
    
-   ![L](https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8): the number of layers
-   ![{\displaystyle W^{l}=(w_{jk}^{l})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6ef80d37cec97e026476841a0e20f9b35c402bd0): the weights between layer ![{\displaystyle l-1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4e0d448948a353d0b2469b88ca918f34e32c8752) and ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac), where ![{\displaystyle w_{jk}^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8f47c5a00989f34da7a6cde720321223af36a019) is the weight between the ![k](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40)\-th node in layer ![{\displaystyle l-1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4e0d448948a353d0b2469b88ca918f34e32c8752) and the ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0)\-th node in layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac)<sup id="cite_ref-20"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-20">[b]</a></sup>
-   ![{\displaystyle f^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ee0e6c373d37a6a029890630310cf35ba6acd174): [activation functions](https://en.wikipedia.org/wiki/Activation_function "Activation function") at layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac)
    
    For classification the last layer is usually the [logistic function](https://en.wikipedia.org/wiki/Logistic_function "Logistic function") for binary classification, and [softmax](https://en.wikipedia.org/wiki/Softmax_function "Softmax function") (softargmax) for multi-class classification, while for the hidden layers this was traditionally a [sigmoid function](https://en.wikipedia.org/wiki/Sigmoid_function "Sigmoid function") (logistic function or others) on each node (coordinate), but today is more varied, with [rectifier](https://en.wikipedia.org/wiki/Rectifier_(neural_networks) "Rectifier (neural networks)") ([ramp](https://en.wikipedia.org/wiki/Ramp_function "Ramp function"), [ReLU](https://en.wikipedia.org/wiki/ReLU "ReLU")) being common.
    
-   ![{\displaystyle a_{j}^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/fbb8152a0d8674023edebc1a8760c3ef478831d8): activation of the ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0)\-th node in layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac).

In the derivation of backpropagation, other intermediate quantities are used by introducing them as needed below. Bias terms are not treated specially since they correspond to a weight with a fixed input of 1. For backpropagation the specific loss function and activation functions do not matter as long as they and their derivatives can be evaluated efficiently. Traditional activation functions include sigmoid, tanh, and [ReLU](https://en.wikipedia.org/wiki/Rectifier_(neural_networks) "Rectifier (neural networks)"). [swish](https://en.wikipedia.org/wiki/Swish_function "Swish function")<sup id="cite_ref-21"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-21">[19]</a></sup> [mish](https://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Mish "Rectifier (neural networks)"),<sup id="cite_ref-22"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-22">[20]</a></sup> and other activation functions have since been proposed as well.

The overall network is a combination of [function composition](https://en.wikipedia.org/wiki/Function_composition "Function composition") and [matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication "Matrix multiplication"):

![{\displaystyle g(x):=f^{L}(W^{L}f^{L-1}(W^{L-1}\cdots f^{1}(W^{1}x)\cdots ))}](https://wikimedia.org/api/rest_v1/media/math/render/svg/110b3c8ee790c91cf79a882f1515f6f05f8db335)

For a training set there will be a set of input–output pairs, ![{\displaystyle \left\{(x_{i},y_{i})\right\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/26d74b1e662ee0f0e1604f2e5a63fde1456bb19e). For each input–output pair ![(x_{i},y_{i})](https://wikimedia.org/api/rest_v1/media/math/render/svg/d6dbb919b91ccacf17ed47898048428a1baf9703) in the training set, the loss of the model on that pair is the cost of the difference between the predicted output ![{\displaystyle g(x_{i})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3badcf4ca3e9414821942baee2851b8f9bd27294) and the target output ![y_{i}](https://wikimedia.org/api/rest_v1/media/math/render/svg/67d30d30b6c2dbe4d6f150d699de040937ecc95f):

![{\displaystyle C(y_{i},g(x_{i}))}](https://wikimedia.org/api/rest_v1/media/math/render/svg/57cd91c74155873ce3e1df0fab12d13e7a8f335f)

Note the distinction: during model evaluation the weights are fixed while the inputs vary (and the target output may be unknown), and the network ends with the output layer (it does not include the loss function). During model training the input–output pair is fixed while the weights vary, and the network ends with the loss function.

Backpropagation computes the gradient for a _fixed_ input–output pair ![(x_{i},y_{i})](https://wikimedia.org/api/rest_v1/media/math/render/svg/d6dbb919b91ccacf17ed47898048428a1baf9703), where the weights ![{\displaystyle w_{jk}^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8f47c5a00989f34da7a6cde720321223af36a019) can vary. Each individual component of the gradient, ![{\displaystyle \partial C/\partial w_{jk}^{l},}](https://wikimedia.org/api/rest_v1/media/math/render/svg/924218a6182ed0f43094ec9f5d8a66c4b9b9026f) can be computed by the chain rule; but doing this separately for each weight is inefficient. Backpropagation efficiently computes the gradient by avoiding duplicate calculations and not computing unnecessary intermediate values, by computing the gradient of each layer – specifically the gradient of the weighted _input_ of each layer, denoted by ![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d) – from back to front.

Informally, the key point is that since the only way a weight in ![{\displaystyle W^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/60b87bc8138a82f110491bb1abd0ea6eefe84c22) affects the loss is through its effect on the _next_ layer, and it does so _linearly_, ![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d) are the only data you need to compute the gradients of the weights at layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac), and then the previous layer can be computed ![{\displaystyle \delta ^{l-1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e4ff3faf90011d3ed813a4ac2fe31904765e2963) and repeated recursively. This avoids inefficiency in two ways. First, it avoids duplication because when computing the gradient at layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac) – it is unnecessary to recompute all derivatives on later layers ![{\displaystyle l+1,l+2,\ldots }](https://wikimedia.org/api/rest_v1/media/math/render/svg/49f721be70a4213a6196f3d14f58eb5844eebb1a) each time. Second, it avoids unnecessary intermediate calculations, because at each stage it directly computes the gradient of the weights with respect to the ultimate output (the loss), rather than unnecessarily computing the derivatives of the values of hidden layers with respect to changes in weights ![{\displaystyle \partial a_{j'}^{l'}/\partial w_{jk}^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/67e885d69c5968ab173f51222b89d0701b3459d6).

Backpropagation can be expressed for simple feedforward networks in terms of [matrix multiplication](https://en.wikipedia.org/wiki/Backpropagation#Matrix_multiplication), or more generally in terms of the [adjoint graph](https://en.wikipedia.org/wiki/Backpropagation#Adjoint_graph).

## Matrix multiplication\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=2 "Edit section: Matrix multiplication")\]

For the basic case of a feedforward network, where nodes in each layer are connected only to nodes in the immediate next layer (without skipping any layers), and there is a loss function that computes a scalar loss for the final output, backpropagation can be understood simply by matrix multiplication.<sup id="cite_ref-23"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-23">[c]</a></sup> Essentially, backpropagation evaluates the expression for the derivative of the cost function as a product of derivatives between each layer _from right to left_ – "backwards" – with the gradient of the weights between each layer being a simple modification of the partial products (the "backwards propagated error").

Given an input–output pair ![(x,y)](https://wikimedia.org/api/rest_v1/media/math/render/svg/41cf50e4a314ca8e2c30964baa8d26e5be7a9386), the loss is:

![{\displaystyle C(y,f^{L}(W^{L}f^{L-1}(W^{L-1}\cdots f^{2}(W^{2}f^{1}(W^{1}x))\cdots )))}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3ca8768a6ab49c9e52086741f958221b56b6d03e)

To compute this, one starts with the input ![x](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4) and works forward; denote the weighted input of each hidden layer as ![{\displaystyle z^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3ea4d56d1c5e8fe66b402ea0d1b92368902531dd) and the output of hidden layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac) as the activation ![{\displaystyle a^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/975d9aa9ed78016e94e7438c5af2a6ec8b97a0e9). For backpropagation, the activation ![{\displaystyle a^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/975d9aa9ed78016e94e7438c5af2a6ec8b97a0e9) as well as the derivatives ![{\displaystyle (f^{l})'}](https://wikimedia.org/api/rest_v1/media/math/render/svg/75a2f054b20672fb790ed501c4a39873233d4745) (evaluated at ![{\displaystyle z^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3ea4d56d1c5e8fe66b402ea0d1b92368902531dd)) must be cached for use during the backwards pass.

The derivative of the loss in terms of the inputs is given by the chain rule; note that each term is a [total derivative](https://en.wikipedia.org/wiki/Total_derivative "Total derivative"), evaluated at the value of the network (at each node) on the input ![x](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4):

![{\displaystyle {\frac {dC}{da^{L}}}\cdot {\frac {da^{L}}{dz^{L}}}\cdot {\frac {dz^{L}}{da^{L-1}}}\cdot {\frac {da^{L-1}}{dz^{L-1}}}\cdot {\frac {dz^{L-1}}{da^{L-2}}}\cdot \ldots \cdot {\frac {da^{1}}{dz^{1}}}\cdot {\frac {\partial z^{1}}{\partial x}},}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b758730620b9e4d0b2018f99c3cc270fa8e3bd31)

where ![{\displaystyle {\frac {da^{L}}{dz^{L}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e72728161114c81bdf209852a4157264296326fb) is a diagonal matrix.

These terms are: the derivative of the loss function;<sup id="cite_ref-24"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-24">[d]</a></sup> the derivatives of the activation functions;<sup id="cite_ref-25"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-25">[e]</a></sup> and the matrices of weights:<sup id="cite_ref-26"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-26">[f]</a></sup>

![{\displaystyle {\frac {dC}{da^{L}}}\circ (f^{L})'\cdot W^{L}\circ (f^{L-1})'\cdot W^{L-1}\circ \cdots \circ (f^{1})'\cdot W^{1}.}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f46ed48b7054ef8629f889782c3ffbf953818ca)

The gradient ![\nabla ](https://wikimedia.org/api/rest_v1/media/math/render/svg/a3d0e93b78c50237f9ea83d027e4ebbdaef354b2) is the [transpose](https://en.wikipedia.org/wiki/Transpose "Transpose") of the derivative of the output in terms of the input, so the matrices are transposed and the order of multiplication is reversed, but the entries are the same:

![{\displaystyle \nabla _{x}C=(W^{1})^{T}\cdot (f^{1})'\circ \ldots \circ (W^{L-1})^{T}\cdot (f^{L-1})'\circ (W^{L})^{T}\cdot (f^{L})'\circ \nabla _{a^{L}}C.}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6ef269aa176ce5488ce5f6038eebcb9c8fe3c728)

Backpropagation then consists essentially of evaluating this expression from right to left (equivalently, multiplying the previous expression for the derivative from left to right), computing the gradient at each layer on the way; there is an added step, because the gradient of the weights is not just a subexpression: there's an extra multiplication.

Introducing the auxiliary quantity ![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d) for the partial products (multiplying from right to left), interpreted as the "error at level ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac)" and defined as the gradient of the input values at level ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac):

![{\displaystyle \delta ^{l}:=(f^{l})'\circ (W^{l+1})^{T}\cdot (f^{l+1})'\circ \cdots \circ (W^{L-1})^{T}\cdot (f^{L-1})'\circ (W^{L})^{T}\cdot (f^{L})'\circ \nabla _{a^{L}}C.}](https://wikimedia.org/api/rest_v1/media/math/render/svg/85f95e97ceff3617728642e31c4090869970cad9)

Note that ![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d) is a vector, of length equal to the number of nodes in level ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac); each component is interpreted as the "cost attributable to (the value of) that node".

The gradient of the weights in layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac) is then:

![{\displaystyle \nabla _{W^{l}}C=\delta ^{l}(a^{l-1})^{T}.}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ef23e829ba87604d15ab01965708906c2baa1e4d)

The factor of ![{\displaystyle a^{l-1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5a66d0e6ecb4f486f7e1b63c6ae0a91448624163) is because the weights ![{\displaystyle W^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/60b87bc8138a82f110491bb1abd0ea6eefe84c22) between level ![{\displaystyle l-1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4e0d448948a353d0b2469b88ca918f34e32c8752) and ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac) affect level ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac) proportionally to the inputs (activations): the inputs are fixed, the weights vary.

The ![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d) can easily be computed recursively, going from right to left, as:

![{\displaystyle \delta ^{l-1}:=(f^{l-1})'\circ (W^{l})^{T}\cdot \delta ^{l}.}](https://wikimedia.org/api/rest_v1/media/math/render/svg/16ccb3d3b717f3fa8e1aa72c3a46bbc70945e4cf)

The gradients of the weights can thus be computed using a few matrix multiplications for each level; this is backpropagation.

Compared with naively computing forwards (using the ![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d) for illustration):

![{\displaystyle {\begin{aligned}\delta ^{1}&=(f^{1})'\circ (W^{2})^{T}\cdot (f^{2})'\circ \cdots \circ (W^{L-1})^{T}\cdot (f^{L-1})'\circ (W^{L})^{T}\cdot (f^{L})'\circ \nabla _{a^{L}}C\\\delta ^{2}&=(f^{2})'\circ \cdots \circ (W^{L-1})^{T}\cdot (f^{L-1})'\circ (W^{L})^{T}\cdot (f^{L})'\circ \nabla _{a^{L}}C\\&\vdots \\\delta ^{L-1}&=(f^{L-1})'\circ (W^{L})^{T}\cdot (f^{L})'\circ \nabla _{a^{L}}C\\\delta ^{L}&=(f^{L})'\circ \nabla _{a^{L}}C,\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/65693d61321a41ee6a79f9e24e944f581a33240a)

there are two key differences with backpropagation:

1.  Computing ![{\displaystyle \delta ^{l-1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e4ff3faf90011d3ed813a4ac2fe31904765e2963) in terms of ![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d) avoids the obvious duplicate multiplication of layers ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac) and beyond.
2.  Multiplying starting from ![{\displaystyle \nabla _{a^{L}}C}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0a3491216364a8fe84026d9f114a9477be761c2c) – propagating the error _backwards_ – means that each step simply multiplies a vector (![{\displaystyle \delta ^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/249b787ef6af0149f7d71b951651c43633e0d56d)) by the matrices of weights ![{\displaystyle (W^{l})^{T}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/95ded7046a67e4ea5039c86405383ff82c74308e) and derivatives of activations ![{\displaystyle (f^{l-1})'}](https://wikimedia.org/api/rest_v1/media/math/render/svg/89d6b56875a57b50369e097a55fe50f1be7b9aaf). By contrast, multiplying forwards, starting from the changes at an earlier layer, means that each multiplication multiplies a _matrix_ by a _matrix_. This is much more expensive, and corresponds to tracking every possible path of a change in one layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac) forward to changes in the layer ![{\displaystyle l+2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f96df20468aecf3a1b6dfedd08982cb6edc489bb) (for multiplying ![{\displaystyle W^{l+1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2d3f3b2ac57d2c95e81aafd230d2065e8f8cc401) by ![{\displaystyle W^{l+2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/74caba7e74227959403a15dfc8041720dae8817d), with additional multiplications for the derivatives of the activations), which unnecessarily computes the intermediate quantities of how weight changes affect the values of hidden nodes.

## Adjoint graph\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=3 "Edit section: Adjoint graph")\]

<table role="presentation"><tbody><tr><td><span typeof="mw:File"><a href="https://en.wikipedia.org/wiki/File:Wiki_letter_w_cropped.svg"><img alt="[icon]" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png" decoding="async" width="20" height="14" srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/30px-Wiki_letter_w_cropped.svg.png 1.5x, https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/40px-Wiki_letter_w_cropped.svg.png 2x" data-file-width="44" data-file-height="31"></a></span></td><td><p>This section <b>needs expansion</b>. You can help by <a href="https://en.wikipedia.org/w/index.php?title=Backpropagation&amp;action=edit&amp;section=">adding to it</a>. <span><i>(<span>November 2019</span>)</i></span></p></td></tr></tbody></table>

For more general graphs, and other advanced variations, backpropagation can be understood in terms of [automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation "Automatic differentiation"), where backpropagation is a special case of [reverse accumulation](https://en.wikipedia.org/wiki/Reverse_accumulation "Reverse accumulation") (or "reverse mode").<sup id="cite_ref-DL-reverse-mode_11-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DL-reverse-mode-11">[11]</a></sup>

## Intuition\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=4 "Edit section: Intuition")\]

### Motivation\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=5 "Edit section: Motivation")\]

The goal of any [supervised learning](https://en.wikipedia.org/wiki/Supervised_learning "Supervised learning") algorithm is to find a function that best maps a set of inputs to their correct output. The motivation for backpropagation is to train a multi-layered neural network such that it can learn the appropriate internal representations to allow it to learn any arbitrary mapping of input to output.<sup id="cite_ref-RumelhartHintonWilliams1986a_27-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-RumelhartHintonWilliams1986a-27">[21]</a></sup>

### Learning as an optimization problem\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=6 "Edit section: Learning as an optimization problem")\]

To understand the mathematical derivation of the backpropagation algorithm, it helps to first develop some intuition about the relationship between the actual output of a neuron and the correct output for a particular training example. Consider a simple neural network with two input units, one output unit and no hidden units, and in which each neuron uses a [linear output](https://en.wikipedia.org/wiki/Artificial_neuron#Linear_combination "Artificial neuron") (unlike most work on neural networks, in which mapping from inputs to outputs is non-linear)<sup id="cite_ref-28"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-28">[g]</a></sup> that is the weighted sum of its input.

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/A_simple_neural_network_with_two_input_units_and_one_output_unit.png/250px-A_simple_neural_network_with_two_input_units_and_one_output_unit.png)](https://en.wikipedia.org/wiki/File:A_simple_neural_network_with_two_input_units_and_one_output_unit.png)

A simple neural network with two input units (each with a single input) and one output unit (with two inputs)

Initially, before training, the weights will be set randomly. Then the neuron learns from [training examples](https://en.wikipedia.org/wiki/Training_set "Training set"), which in this case consist of a set of [tuples](https://en.wikipedia.org/wiki/Tuple "Tuple") ![{\displaystyle (x_{1},x_{2},t)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/dbc9205ba047983879ece2f78ff0cf1f7525bdd5) where ![x_{1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a8788bf85d532fa88d1fb25eff6ae382a601c308) and ![x_{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d7af1b928f06e4c7e3e8ebfd60704656719bd766) are the inputs to the network and t is the correct output (the output the network should produce given those inputs, when it has been trained). The initial network, given ![x_{1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a8788bf85d532fa88d1fb25eff6ae382a601c308) and ![x_{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d7af1b928f06e4c7e3e8ebfd60704656719bd766), will compute an output y that likely differs from t (given random weights). A [loss function](https://en.wikipedia.org/wiki/Loss_function "Loss function") ![{\displaystyle L(t,y)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a6d0d207e3b5787cffb4f86784345fe4393893fe) is used for measuring the discrepancy between the target output t and the computed output y. For [regression analysis](https://en.wikipedia.org/wiki/Regression_analysis "Regression analysis") problems the squared error can be used as a loss function, for [classification](https://en.wikipedia.org/wiki/Statistical_classification "Statistical classification") the [categorical cross-entropy](https://en.wikipedia.org/wiki/Cross-entropy "Cross-entropy") can be used.

As an example consider a regression problem using the square error as a loss:

![{\displaystyle L(t,y)=(t-y)^{2}=E,}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ca7e3b55f443f8e490f1e6e552470f93802e5e43)

where E is the discrepancy or error.

Consider the network on a single training case: ![(1, 1, 0)](https://wikimedia.org/api/rest_v1/media/math/render/svg/5568de79a98cdcb48821cd81b670c095fa4c8b6f). Thus, the input ![x_{1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a8788bf85d532fa88d1fb25eff6ae382a601c308) and ![x_{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d7af1b928f06e4c7e3e8ebfd60704656719bd766) are 1 and 1 respectively and the correct output, t is 0. Now if the relation is plotted between the network's output y on the horizontal axis and the error E on the vertical axis, the result is a parabola. The [minimum](https://en.wikipedia.org/wiki/Maxima_and_minima "Maxima and minima") of the [parabola](https://en.wikipedia.org/wiki/Parabola "Parabola") corresponds to the output y which minimizes the error E. For a single training case, the minimum also touches the horizontal axis, which means the error will be zero and the network can produce an output y that exactly matches the target output t. Therefore, the problem of mapping inputs to outputs can be reduced to an [optimization problem](https://en.wikipedia.org/wiki/Optimization_problem "Optimization problem") of finding a function that will produce the minimal error.

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Error_surface_of_a_linear_neuron_for_a_single_training_case.png/250px-Error_surface_of_a_linear_neuron_for_a_single_training_case.png)](https://en.wikipedia.org/wiki/File:Error_surface_of_a_linear_neuron_for_a_single_training_case.png)

Error surface of a linear neuron for a single training case

However, the output of a neuron depends on the weighted sum of all its inputs:

![{\displaystyle y=x_{1}w_{1}+x_{2}w_{2},}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6297e881012aa2988838c056f86c589828b80e7d)

where ![w_{1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f6728d2b30f42f88b52281be5ae0584fdc9df64) and ![w_{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8998e0957bb573a19e7d9d934ced62ee68ab8fb8) are the weights on the connection from the input units to the output unit. Therefore, the error also depends on the incoming weights to the neuron, which is ultimately what needs to be changed in the network to enable learning.

In this example, upon injecting the training data ![(1, 1, 0)](https://wikimedia.org/api/rest_v1/media/math/render/svg/5568de79a98cdcb48821cd81b670c095fa4c8b6f), the loss function becomes

![{\displaystyle E=(t-y)^{2}=y^{2}=(x_{1}w_{1}+x_{2}w_{2})^{2}=(w_{1}+w_{2})^{2}.}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9642579185c542b0e8312a7edeeacf6abbb8934f)

Then, the loss function ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b) takes the form of a parabolic cylinder with its base directed along ![{\displaystyle w_{1}=-w_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/839b25f7684ef2b1c6f960f962d64c0e993520b2). Since all sets of weights that satisfy ![{\displaystyle w_{1}=-w_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/839b25f7684ef2b1c6f960f962d64c0e993520b2) minimize the loss function, in this case additional constraints are required to converge to a unique solution. Additional constraints could either be generated by setting specific conditions to the weights, or by injecting additional training data.

One commonly used algorithm to find the set of weights that minimizes the error is [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent "Gradient descent"). By backpropagation, the steepest descent direction is calculated of the loss function versus the present synaptic weights. Then, the weights can be modified along the steepest descent direction, and the error is minimized in an efficient way.

## Derivation\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=7 "Edit section: Derivation")\]

The gradient descent method involves calculating the derivative of the loss function with respect to the weights of the network. This is normally done using backpropagation. Assuming one output neuron,<sup id="cite_ref-29"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-29">[h]</a></sup> the squared error function is

![{\displaystyle E=L(t,y)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9db5e7ae55377b930b4bdaa8821d33fef2217792)

where

![L](https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8) is the loss for the output ![y](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d) and target value ![t](https://wikimedia.org/api/rest_v1/media/math/render/svg/65658b7b223af9e1acc877d848888ecdb4466560),

![t](https://wikimedia.org/api/rest_v1/media/math/render/svg/65658b7b223af9e1acc877d848888ecdb4466560) is the target output for a training sample, and

![y](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d) is the actual output of the output neuron.

For each neuron ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0), its output ![o_j](https://wikimedia.org/api/rest_v1/media/math/render/svg/0229f31d42e856d5af6aa970042abed37bce87f9) is defined as

![{\displaystyle o_{j}=\varphi ({\text{net}}_{j})=\varphi \left(\sum _{k=1}^{n}w_{kj}x_{k}\right),}](https://wikimedia.org/api/rest_v1/media/math/render/svg/538346d8b13891ef0ca6ae18e6e4ccd68964458a)

where the [activation function](https://en.wikipedia.org/wiki/Activation_function "Activation function") ![\varphi ](https://wikimedia.org/api/rest_v1/media/math/render/svg/33ee699558d09cf9d653f6351f9fda0b2f4aaa3e) is [non-linear](https://en.wikipedia.org/wiki/Non-linear "Non-linear") and [differentiable](https://en.wikipedia.org/wiki/Differentiable_function "Differentiable function") over the activation region (the ReLU is not differentiable at one point). A historically used activation function is the [logistic function](https://en.wikipedia.org/wiki/Logistic_function "Logistic function"):

![{\displaystyle \varphi (z)={\frac {1}{1+e^{-z}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3d4d1a31c11f8fc840738cf30326c08cfcdba81)

which has a convenient derivative of:

![{\displaystyle {\frac {d\varphi }{dz}}=\varphi (z)(1-\varphi (z))}](https://wikimedia.org/api/rest_v1/media/math/render/svg/52ed6ebbb4540ca08b3be2f1dbddd08d43304a83)

The input ![{\displaystyle {\text{net}}_{j}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ac5fc6b518b9eb768d6dfd4946640ea28f217dd3) to a neuron is the weighted sum of outputs ![o_k](https://wikimedia.org/api/rest_v1/media/math/render/svg/1e57d19af3dbdeb11490339d1e35976411d5dc35) of previous neurons. If the neuron is in the first layer after the input layer, the ![o_k](https://wikimedia.org/api/rest_v1/media/math/render/svg/1e57d19af3dbdeb11490339d1e35976411d5dc35) of the input layer are simply the inputs ![x_{k}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6d2b88c64c76a03611549fb9b4cf4ed060b56002) to the network. The number of input units to the neuron is ![n](https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b). The variable ![{\displaystyle w_{kj}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f648fa9eb42b941e1320b741cbb73467a5bffcb3) denotes the weight between neuron ![k](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40) of the previous layer and neuron ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0) of the current layer.

### Finding the derivative of the error\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=8 "Edit section: Finding the derivative of the error")\]

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/ArtificialNeuronModel_english.png/400px-ArtificialNeuronModel_english.png)](https://en.wikipedia.org/wiki/File:ArtificialNeuronModel_english.png)

Diagram of an artificial neural network to illustrate the notation used here

Calculating the [partial derivative](https://en.wikipedia.org/wiki/Partial_derivative "Partial derivative") of the error with respect to a weight ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321) is done using the [chain rule](https://en.wikipedia.org/wiki/Chain_rule "Chain rule") twice:

<table role="presentation"><tbody><tr><td><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b7c054e1332677921beedc7def4b32ceca971b44" aria-hidden="true" alt="{\displaystyle {\frac {\partial E}{\partial w_{ij}}}={\frac {\partial E}{\partial o_{j}}}{\frac {\partial o_{j}}{\partial w_{ij}}}={\frac {\partial E}{\partial o_{j}}}{\frac {\partial o_{j}}{\partial {\text{net}}_{j}}}{\frac {\partial {\text{net}}_{j}}{\partial w_{ij}}}}"></span></p></td><td></td><td><p><b>(<span id="math_Eq._1">Eq. 1</span>)</b></p></td></tr></tbody></table>

In the last factor of the right-hand side of the above, only one term in the sum ![{\displaystyle {\text{net}}_{j}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ac5fc6b518b9eb768d6dfd4946640ea28f217dd3) depends on ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321), so that

<table role="presentation"><tbody><tr><td><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87fdc283f4d19b228713c6fdadf64deffd4ce295" aria-hidden="true" alt="{\displaystyle {\frac {\partial {\text{net}}_{j}}{\partial w_{ij}}}={\frac {\partial }{\partial w_{ij}}}\left(\sum _{k=1}^{n}w_{kj}o_{k}\right)={\frac {\partial }{\partial w_{ij}}}w_{ij}o_{i}=o_{i}.}"></span></p></td><td></td><td><p><b>(<span id="math_Eq._2">Eq. 2</span>)</b></p></td></tr></tbody></table>

If the neuron is in the first layer after the input layer, ![o_i](https://wikimedia.org/api/rest_v1/media/math/render/svg/c81b6f1251a0d2e12011a746b586c5fa9a132d48) is just ![x_{i}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e87000dd6142b81d041896a30fe58f0c3acb2158).

The derivative of the output of neuron ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0) with respect to its input is simply the partial derivative of the activation function:

<table role="presentation"><tbody><tr><td><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73b9894f8477285b84c45f6a9715958c02160aee" aria-hidden="true" alt="{\displaystyle {\frac {\partial o_{j}}{\partial {\text{net}}_{j}}}={\frac {\partial \varphi ({\text{net}}_{j})}{\partial {\text{net}}_{j}}}}"></span></p></td><td></td><td><p><b>(<span id="math_Eq._3">Eq. 3</span>)</b></p></td></tr></tbody></table>

which for the [logistic activation function](https://en.wikipedia.org/wiki/Logistic_function "Logistic function")

![{\displaystyle {\frac {\partial o_{j}}{\partial {\text{net}}_{j}}}={\frac {\partial }{\partial {\text{net}}_{j}}}\varphi ({\text{net}}_{j})=\varphi ({\text{net}}_{j})(1-\varphi ({\text{net}}_{j}))=o_{j}(1-o_{j})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ed36b5ea1321f0aca92fcb00068a8d083ec006f1)

This is the reason why backpropagation requires that the activation function be [differentiable](https://en.wikipedia.org/wiki/Differentiable_function "Differentiable function"). (Nevertheless, the [ReLU](https://en.wikipedia.org/wiki/ReLU "ReLU") activation function, which is non-differentiable at 0, has become quite popular, e.g. in [AlexNet](https://en.wikipedia.org/wiki/AlexNet "AlexNet"))

The first factor is straightforward to evaluate if the neuron is in the output layer, because then ![o_j = y](https://wikimedia.org/api/rest_v1/media/math/render/svg/0543b379df7f7599d89d6317e7e11013941e2885) and

<table role="presentation"><tbody><tr><td><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2d8fc0377bcf7268953a268d289a47b23e2dc37f" aria-hidden="true" alt="{\displaystyle {\frac {\partial E}{\partial o_{j}}}={\frac {\partial E}{\partial y}}}"></span></p></td><td></td><td><p><b>(<span id="math_Eq._4">Eq. 4</span>)</b></p></td></tr></tbody></table>

If half of the square error is used as loss function we can rewrite it as

![\frac{\partial E}{\partial o_j} = \frac{\partial E}{\partial y} = \frac{\partial}{\partial y} \frac{1}{2}(t - y)^2 = y - t ](https://wikimedia.org/api/rest_v1/media/math/render/svg/39d55b81fdb2681ab5957f3e03b9150b6d043c36)

However, if ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0) is in an arbitrary inner layer of the network, finding the derivative ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b) with respect to ![o_j](https://wikimedia.org/api/rest_v1/media/math/render/svg/0229f31d42e856d5af6aa970042abed37bce87f9) is less obvious.

Considering ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b) as a function with the inputs being all neurons ![{\displaystyle L=\{u,v,\dots ,w\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c4abf35b7ef5693f8765266665cb87e9819cb2a7) receiving input from neuron ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0),

![{\displaystyle {\frac {\partial E(o_{j})}{\partial o_{j}}}={\frac {\partial E(\mathrm {net} _{u},{\text{net}}_{v},\dots ,\mathrm {net} _{w})}{\partial o_{j}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e660d78517bc99de7a438a69171dcdb7dd88740b)

and taking the [total derivative](https://en.wikipedia.org/wiki/Total_derivative "Total derivative") with respect to ![o_j](https://wikimedia.org/api/rest_v1/media/math/render/svg/0229f31d42e856d5af6aa970042abed37bce87f9), a recursive expression for the derivative is obtained:

<table role="presentation"><tbody><tr><td><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c9887a99d44591e541893407e952ea0d50ed798e" aria-hidden="true" alt="{\displaystyle {\frac {\partial E}{\partial o_{j}}}=\sum _{\ell \in L}\left({\frac {\partial E}{\partial {\text{net}}_{\ell }}}{\frac {\partial {\text{net}}_{\ell }}{\partial o_{j}}}\right)=\sum _{\ell \in L}\left({\frac {\partial E}{\partial o_{\ell }}}{\frac {\partial o_{\ell }}{\partial {\text{net}}_{\ell }}}{\frac {\partial {\text{net}}_{\ell }}{\partial o_{j}}}\right)=\sum _{\ell \in L}\left({\frac {\partial E}{\partial o_{\ell }}}{\frac {\partial o_{\ell }}{\partial {\text{net}}_{\ell }}}w_{j\ell }\right)}"></span></p></td><td></td><td><p><b>(<span id="math_Eq._5">Eq. 5</span>)</b></p></td></tr></tbody></table>

Therefore, the derivative with respect to ![o_j](https://wikimedia.org/api/rest_v1/media/math/render/svg/0229f31d42e856d5af6aa970042abed37bce87f9) can be calculated if all the derivatives with respect to the outputs ![{\displaystyle o_{\ell }}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c2901ae7228e6fb253eb223344d54c70ccccaf00) of the next layer – the ones closer to the output neuron – are known. \[Note, if any of the neurons in set ![L](https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8) were not connected to neuron ![j](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0), they would be independent of ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321) and the corresponding partial derivative under the summation would vanish to 0.\]

Substituting **[Eq. 2](https://en.wikipedia.org/wiki/Backpropagation#math_Eq._2)**, **[Eq. 3](https://en.wikipedia.org/wiki/Backpropagation#math_Eq._3)** **[Eq.4](https://en.wikipedia.org/wiki/Backpropagation#math_Eq.4)** and **[Eq. 5](https://en.wikipedia.org/wiki/Backpropagation#math_Eq._5)** in **[Eq. 1](https://en.wikipedia.org/wiki/Backpropagation#math_Eq._1)** we obtain:

![{\displaystyle {\frac {\partial E}{\partial w_{ij}}}={\frac {\partial E}{\partial o_{j}}}{\frac {\partial o_{j}}{\partial {\text{net}}_{j}}}{\frac {\partial {\text{net}}_{j}}{\partial w_{ij}}}={\frac {\partial E}{\partial o_{j}}}{\frac {\partial o_{j}}{\partial {\text{net}}_{j}}}o_{i}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ae55d1c0135131a9b5c0db89f5e20ffae8bc7040)

![{\displaystyle {\frac {\partial E}{\partial w_{ij}}}=o_{i}\delta _{j}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e86f74f9e33c38bc1d5664ddd9794da381976af3)

with

![{\displaystyle \delta _{j}={\frac {\partial E}{\partial o_{j}}}{\frac {\partial o_{j}}{\partial {\text{net}}_{j}}}={\begin{cases}{\frac {\partial L(t,o_{j})}{\partial o_{j}}}{\frac {d\varphi ({\text{net}}_{j})}{d{\text{net}}_{j}}}&{\text{if }}j{\text{ is an output neuron,}}\\(\sum _{\ell \in L}w_{j\ell }\delta _{\ell }){\frac {d\varphi ({\text{net}}_{j})}{d{\text{net}}_{j}}}&{\text{if }}j{\text{ is an inner neuron.}}\end{cases}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/54de826820eed0648c7dba5e345120bb23483261)

if ![\varphi ](https://wikimedia.org/api/rest_v1/media/math/render/svg/33ee699558d09cf9d653f6351f9fda0b2f4aaa3e) is the logistic function, and the error is the square error:

![{\displaystyle \delta _{j}={\frac {\partial E}{\partial o_{j}}}{\frac {\partial o_{j}}{\partial {\text{net}}_{j}}}={\begin{cases}(o_{j}-t_{j})o_{j}(1-o_{j})&{\text{if }}j{\text{ is an output neuron,}}\\(\sum _{\ell \in L}w_{j\ell }\delta _{\ell })o_{j}(1-o_{j})&{\text{if }}j{\text{ is an inner neuron.}}\end{cases}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/991c8f020800ec1da130849e20a3a415613e9bdb)

To update the weight ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321) using gradient descent, one must choose a learning rate, ![{\displaystyle \eta >0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ce70a0b6474dcb5aaeea68b799038e8f60b54ef1). The change in weight needs to reflect the impact on ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b) of an increase or decrease in ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321). If ![{\displaystyle {\frac {\partial E}{\partial w_{ij}}}>0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/52a50d4d1cc9a82d13f38ab6317adcbdb24b9112), an increase in ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321) increases ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b); conversely, if ![{\displaystyle {\frac {\partial E}{\partial w_{ij}}}<0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5669ee0bda9e01723c570b9496abbe4bdbd96357), an increase in ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321) decreases ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b). The new ![{\displaystyle \Delta w_{ij}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/75343e68050b7d0bc74986719687a845095ad59f) is added to the old weight, and the product of the learning rate and the gradient, multiplied by ![-1](https://wikimedia.org/api/rest_v1/media/math/render/svg/704fb0427140d054dd267925495e78164fee9aac) guarantees that ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321) changes in a way that always decreases ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b). In other words, in the equation immediately below, ![{\displaystyle -\eta {\frac {\partial E}{\partial w_{ij}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f908b3074295c5281b9f6363c4dd65cca7476c) always changes ![w_{ij}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d3302ff355269436b43bc2fbe180303881c09321) in such a way that ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b) is decreased:

![{\displaystyle \Delta w_{ij}=-\eta {\frac {\partial E}{\partial w_{ij}}}=-\eta o_{i}\delta _{j}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/19e12758145196a841af866e8dfa2437d35c82e8)

## Second-order gradient descent\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=9 "Edit section: Second-order gradient descent")\]

Using a [Hessian matrix](https://en.wikipedia.org/wiki/Hessian_matrix "Hessian matrix") of second-order derivatives of the error function, the [Levenberg–Marquardt algorithm](https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm "Levenberg–Marquardt algorithm") often converges faster than first-order gradient descent, especially when the topology of the error function is complicated.<sup id="cite_ref-Tan2018_30-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-Tan2018-30">[22]</a></sup><sup id="cite_ref-Wiliamowski2010_31-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-Wiliamowski2010-31">[23]</a></sup> It may also find solutions in smaller node counts for which other methods might not converge.<sup id="cite_ref-Wiliamowski2010_31-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-Wiliamowski2010-31">[23]</a></sup> The Hessian can be approximated by the [Fisher information](https://en.wikipedia.org/wiki/Fisher_information "Fisher information") matrix.<sup id="cite_ref-Martens2020_32-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-Martens2020-32">[24]</a></sup>

## Loss function\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=10 "Edit section: Loss function")\]

The loss function is a function that maps values of one or more variables onto a [real number](https://en.wikipedia.org/wiki/Real_number "Real number") intuitively representing some "cost" associated with those values. For backpropagation, the loss function calculates the difference between the network output and its expected output, after a training example has propagated through the network.

### Assumptions\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=11 "Edit section: Assumptions")\]

The mathematical expression of the loss function must fulfill two conditions in order for it to be possibly used in backpropagation.<sup id="cite_ref-33"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-33">[25]</a></sup> The first is that it can be written as an average ![{\textstyle E={\frac {1}{n}}\sum _{x}E_{x}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/10d86f4c725f4158341b538f99eacc618e640b78) over error functions ![{\textstyle E_{x}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/fa289d8c2030c92095fe10836f648984bd80d10b), for ![{\textstyle n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cc6e1f880981346a604257ebcacdef24c0aca2d6) individual training examples, ![{\textstyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d951e0f3b54b6a3d73bb9a0a005749046cbce781). The reason for this assumption is that the backpropagation algorithm calculates the gradient of the error function for a single training example, which needs to be generalized to the overall error function. The second assumption is that it can be written as a function of the outputs from the neural network.

### Example loss function\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=12 "Edit section: Example loss function")\]

Let ![{\displaystyle y,y'}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b7de53e950ff33763c8d524e32280498ec480f86) be vectors in ![\mathbb {R} ^{n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c510b63578322050121fe966f2e5770bea43308d).

Select an error function ![{\displaystyle E(y,y')}](https://wikimedia.org/api/rest_v1/media/math/render/svg/15c4c7f9edb4d4a5ca9844bfb82f947363d0d40f) measuring the difference between two outputs. The standard choice is the square of the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance "Euclidean distance") between the vectors ![y](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d) and ![y'](https://wikimedia.org/api/rest_v1/media/math/render/svg/3a535de94a2183d7130731eab8a83531d7c35c6b):

![{\displaystyle E(y,y')={\tfrac {1}{2}}\lVert y-y'\rVert ^{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/11ae60805a3914707a33ece46b0d46700262e028)

The error function over ![{\textstyle n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cc6e1f880981346a604257ebcacdef24c0aca2d6) training examples can then be written as an average of losses over individual examples:

![{\displaystyle E={\frac {1}{2n}}\sum _{x}\lVert (y(x)-y'(x))\rVert ^{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/774b3a3904cbcc2ea2768491f4df2cf1c041563c)

## Limitations\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=13 "Edit section: Limitations")\]

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Extrema_example.svg/250px-Extrema_example.svg.png)](https://en.wikipedia.org/wiki/File:Extrema_example.svg)

Gradient descent may find a local minimum instead of the global minimum.

-   Gradient descent with backpropagation is not guaranteed to find the [global minimum](https://en.wikipedia.org/wiki/Maxima_and_minima "Maxima and minima") of the error function, but only a local minimum; also, it has trouble crossing [plateaus](https://en.wikipedia.org/wiki/Plateau_(mathematics) "Plateau (mathematics)") in the error function landscape. This issue, caused by the [non-convexity](https://en.wikipedia.org/wiki/Convex_optimization "Convex optimization") of error functions in neural networks, was long thought to be a major drawback, but [Yann LeCun](https://en.wikipedia.org/wiki/Yann_LeCun "Yann LeCun") _et al._ argue that in many practical problems, it is not.<sup id="cite_ref-34"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-34">[26]</a></sup>
-   Backpropagation learning does not require normalization of input vectors; however, normalization could improve performance.<sup id="cite_ref-35"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-35">[27]</a></sup>
-   Backpropagation requires the derivatives of activation functions to be known at network design time.

## History\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=14 "Edit section: History")\]

Modern backpropagation is [Seppo Linnainmaa](https://en.wikipedia.org/wiki/Seppo_Linnainmaa "Seppo Linnainmaa")'s reverse mode of [automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation "Automatic differentiation") (1970) for discrete connected networks of nested [differentiable](https://en.wikipedia.org/wiki/Differentiable_function "Differentiable function") functions.<sup id="cite_ref-lin1970_5-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-lin1970-5">[5]</a></sup><sup id="cite_ref-lin1976_6-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-lin1976-6">[6]</a></sup><sup id="cite_ref-schmidhuber2015_9-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-schmidhuber2015-9">[9]</a></sup><sup id="cite_ref-scholarpedia2015_10-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-scholarpedia2015-10">[10]</a></sup><sup id="cite_ref-grie2012_7-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-grie2012-7">[7]</a></sup><sup id="cite_ref-grie2008_8-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-grie2008-8">[8]</a></sup> It is an efficient application of the [chain rule](https://en.wikipedia.org/wiki/Chain_rule "Chain rule") (derived by [Gottfried Wilhelm Leibniz](https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz "Gottfried Wilhelm Leibniz") in 1673<sup id="cite_ref-leibniz1676_3-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-leibniz1676-3">[3]</a></sup><sup id="cite_ref-36"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-36">[28]</a></sup>) to such networks.<sup id="cite_ref-DLhistory_4-3"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> The terminology "back-propagating error correction" was introduced in 1962 by [Frank Rosenblatt](https://en.wikipedia.org/wiki/Frank_Rosenblatt "Frank Rosenblatt"),<sup id="cite_ref-37"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-37">[29]</a></sup><sup id="cite_ref-DLhistory_4-4"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> but he did not know how to implement this, although [Henry J. Kelley](https://en.wikipedia.org/wiki/Henry_J._Kelley "Henry J. Kelley") had a continuous precursor of backpropagation<sup id="cite_ref-kelley1960_13-2"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-kelley1960-13">[13]</a></sup> already in 1960 in the context of [control theory](https://en.wikipedia.org/wiki/Control_theory "Control theory").<sup id="cite_ref-DLhistory_4-5"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> The first [deep learning](https://en.wikipedia.org/wiki/Deep_learning "Deep learning") [multilayer perceptron](https://en.wikipedia.org/wiki/Multilayer_perceptron "Multilayer perceptron") (MLP) trained by [stochastic gradient descent](https://en.wikipedia.org/wiki/Stochastic_gradient_descent "Stochastic gradient descent")<sup id="cite_ref-robbins1951_16-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-robbins1951-16">[16]</a></sup> was published in 1967 by [Shun'ichi Amari](https://en.wikipedia.org/wiki/Shun%27ichi_Amari "Shun'ichi Amari").<sup id="cite_ref-Amari1967_38-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-Amari1967-38">[30]</a></sup><sup id="cite_ref-DLhistory_4-6"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> In computer experiments, his five layer MLP with two modifiable layers learned [internal representations](https://en.wikipedia.org/wiki/Knowledge_representation "Knowledge representation") required to classify non-linearily separable pattern classes.<sup id="cite_ref-DLhistory_4-7"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> In 1982, [Paul Werbos](https://en.wikipedia.org/wiki/Paul_Werbos "Paul Werbos") applied backpropagation to MLPs in the way that has become standard.<sup id="cite_ref-werbos1982_39-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-werbos1982-39">[31]</a></sup><sup id="cite_ref-werbos1974_40-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-werbos1974-40">[32]</a></sup><sup id="cite_ref-DLhistory_4-8"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup> In 1985, [David E. Rumelhart](https://en.wikipedia.org/wiki/David_E._Rumelhart "David E. Rumelhart") et al. published an experimental analysis of the technique.<sup id="cite_ref-learning-representations_18-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-learning-representations-18">[18]</a></sup> This contributed to the popularization of backpropagation and helped to initiate an active period of research in [multilayer perceptrons](https://en.wikipedia.org/wiki/Multilayer_perceptron "Multilayer perceptron").<sup id="cite_ref-RumelhartHintonWilliams1986a_27-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-RumelhartHintonWilliams1986a-27">[21]</a></sup><sup id="cite_ref-RumelhartHintonWilliams1986b_41-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-RumelhartHintonWilliams1986b-41">[33]</a></sup><sup id="cite_ref-42"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-42">[34]</a></sup>

Kelley (1960)<sup id="cite_ref-kelley1960_13-3"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-kelley1960-13">[13]</a></sup> and [Arthur E. Bryson](https://en.wikipedia.org/wiki/Arthur_E._Bryson "Arthur E. Bryson") (1961)<sup id="cite_ref-bryson1961_14-1"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-bryson1961-14">[14]</a></sup> used principles of [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming "Dynamic programming") to derive the above-mentioned continuous precursor of the method. In 1962, [Stuart Dreyfus](https://en.wikipedia.org/wiki/Stuart_Dreyfus "Stuart Dreyfus") published a simpler derivation based only on the [chain rule](https://en.wikipedia.org/wiki/Chain_rule "Chain rule").<sup id="cite_ref-43"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-43">[35]</a></sup><sup id="cite_ref-dreyfus1990_44-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-dreyfus1990-44">[36]</a></sup><sup id="cite_ref-45"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-45">[37]</a></sup><sup id="cite_ref-schmidhuber2015_9-2"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-schmidhuber2015-9">[9]</a></sup><sup id="cite_ref-scholarpedia2015_10-2"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-scholarpedia2015-10">[10]</a></sup> In 1973, he adapted [parameters](https://en.wikipedia.org/wiki/Parameter "Parameter") of controllers in proportion to error gradients.<sup id="cite_ref-dreyfus1973_46-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-dreyfus1973-46">[38]</a></sup> Unlike Linnainmaa's 1970 method,<sup id="cite_ref-lin1970_5-2"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-lin1970-5">[5]</a></sup><sup id="cite_ref-grie2012_7-2"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-grie2012-7">[7]</a></sup> these precursors used "standard Jacobian matrix calculations from one stage to the previous one, neither addressing direct links across several stages nor potential additional efficiency gains due to network sparsity."<sup id="cite_ref-DLhistory_4-9"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-DLhistory-4">[4]</a></sup>

In 1985, the method was also described by Parker.<sup id="cite_ref-47"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-47">[39]</a></sup><sup id="cite_ref-:0_48-0"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-:0-48">[40]</a></sup> [Yann LeCun](https://en.wikipedia.org/wiki/Yann_LeCun "Yann LeCun") proposed an alternative form of backpropagation for neural networks in his PhD thesis in 1987. In 1993, Eric Wan won an international pattern recognition contest through backpropagation.<sup id="cite_ref-schmidhuber2015_9-3"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-schmidhuber2015-9">[9]</a></sup><sup id="cite_ref-49"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-49">[41]</a></sup>

During the 2000s it fell out of favour<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (February 2022)">citation needed</span></a></i>]</sup>, but returned in the 2010s, benefitting from cheap, powerful [GPU](https://en.wikipedia.org/wiki/GPU "GPU")\-based computing systems. This has been especially so in [speech recognition](https://en.wikipedia.org/wiki/Speech_recognition "Speech recognition"), [machine vision](https://en.wikipedia.org/wiki/Machine_vision "Machine vision"), [natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing "Natural language processing"), and language structure learning research (in which it has been used to explain a variety of phenomena related to first<sup id="cite_ref-50"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-50">[42]</a></sup> and second language learning.<sup id="cite_ref-51"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-51">[43]</a></sup>).

Error backpropagation has been suggested to explain human brain [ERP](https://en.wikipedia.org/wiki/Event-related_potential "Event-related potential") components like the [N400](https://en.wikipedia.org/wiki/N400_(neuroscience) "N400 (neuroscience)") and [P600](https://en.wikipedia.org/wiki/P600_(neuroscience) "P600 (neuroscience)").<sup id="cite_ref-52"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-52">[44]</a></sup>

In 2023, a backpropagation algorithm was implemented on a [photonic processor](https://en.wikipedia.org/wiki/Photonic_processor "Photonic processor") by a team at [Stanford University](https://en.wikipedia.org/wiki/Stanford_University "Stanford University").<sup id="cite_ref-53"><a href="https://en.wikipedia.org/wiki/Backpropagation#cite_note-53">[45]</a></sup>

## See also\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=15 "Edit section: See also")\]

-   [Artificial neural network](https://en.wikipedia.org/wiki/Artificial_neural_network "Artificial neural network")
-   [Neural circuit](https://en.wikipedia.org/wiki/Neural_circuit "Neural circuit")
-   [Catastrophic interference](https://en.wikipedia.org/wiki/Catastrophic_interference "Catastrophic interference")
-   [Ensemble learning](https://en.wikipedia.org/wiki/Ensemble_learning "Ensemble learning")
-   [AdaBoost](https://en.wikipedia.org/wiki/AdaBoost "AdaBoost")
-   [Overfitting](https://en.wikipedia.org/wiki/Overfitting "Overfitting")
-   [Neural backpropagation](https://en.wikipedia.org/wiki/Neural_backpropagation "Neural backpropagation")
-   [Backpropagation through time](https://en.wikipedia.org/wiki/Backpropagation_through_time "Backpropagation through time")

## Notes\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=16 "Edit section: Notes")\]

1.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-19 "Jump up")** Use ![C](https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029) for the loss function to allow ![L](https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8) to be used for the number of layers
2.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-20 "Jump up")** This follows [Nielsen (2015)](https://en.wikipedia.org/wiki/Backpropagation#CITEREFNielsen2015), and means (left) multiplication by the matrix ![{\displaystyle W^{l}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/60b87bc8138a82f110491bb1abd0ea6eefe84c22) corresponds to converting output values of layer ![{\displaystyle l-1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4e0d448948a353d0b2469b88ca918f34e32c8752) to input values of layer ![l](https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac): columns correspond to input coordinates, rows correspond to output coordinates.
3.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-23 "Jump up")** This section largely follows and summarizes [Nielsen (2015)](https://en.wikipedia.org/wiki/Backpropagation#CITEREFNielsen2015).
4.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-24 "Jump up")** The derivative of the loss function is a [covector](https://en.wikipedia.org/wiki/Covector "Covector"), since the loss function is a [scalar-valued function](https://en.wikipedia.org/wiki/Scalar-valued_function "Scalar-valued function") of several variables.
5.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-25 "Jump up")** The activation function is applied to each node separately, so the derivative is just the [diagonal matrix](https://en.wikipedia.org/wiki/Diagonal_matrix "Diagonal matrix") of the derivative on each node. This is often represented as the [Hadamard product](https://en.wikipedia.org/wiki/Hadamard_product_(matrices) "Hadamard product (matrices)") with the vector of derivatives, denoted by ![{\displaystyle (f^{l})'\odot }](https://wikimedia.org/api/rest_v1/media/math/render/svg/ee57033dfe04a65842e5260c85240f9295cb464c), which is mathematically identical but better matches the internal representation of the derivatives as a vector, rather than a diagonal matrix.
6.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-26 "Jump up")** Since matrix multiplication is linear, the derivative of multiplying by a matrix is just the matrix: ![{\displaystyle (Wx)'=W}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0beeadf03249427d72b4c95732f23143fdfd6c30).
7.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-28 "Jump up")** One may notice that multi-layer neural networks use non-linear activation functions, so an example with linear neurons seems obscure. However, even though the error surface of multi-layer networks are much more complicated, locally they can be approximated by a paraboloid. Therefore, linear neurons are used for simplicity and easier understanding.
8.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-29 "Jump up")** There can be multiple output neurons, in which case the error is the squared norm of the difference vector.

## References\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=17 "Edit section: References")\]

1.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-1 "Jump up")** [Goodfellow, Bengio & Courville 2016](https://en.wikipedia.org/wiki/Backpropagation#CITEREFGoodfellowBengioCourville2016), p. [200](https://www.deeplearningbook.org/contents/mlp.html#pf25), "Furthermore, back-propagation is often misunderstood as being specific to multi-layer neural networks, but in principle it can compute derivatives of any function"
2.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-arxiv_2-0 "Jump up")** Graves, Alex; Wayne, Greg; Danihelka, Ivo (2014). "Neural Turing Machines". [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[1410.5401](https://arxiv.org/abs/1410.5401) \[[cs.NE](https://arxiv.org/archive/cs.NE)\].
3.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-leibniz1676_3-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-leibniz1676_3-1) Leibniz, Gottfried Wilhelm Freiherr von (1920). [_The Early Mathematical Manuscripts of Leibniz: Translated from the Latin Texts Published by Carl Immanuel Gerhardt with Critical and Historical Notes (Leibniz published the chain rule in a 1676 memoir)_](https://books.google.com/books?id=bOIGAAAAYAAJ&q=leibniz+altered+manuscripts&pg=PA90). Open court publishing Company. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [9780598818461](https://en.wikipedia.org/wiki/Special:BookSources/9780598818461 "Special:BookSources/9780598818461").
4.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-2) [<sup><i><b>d</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-3) [<sup><i><b>e</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-4) [<sup><i><b>f</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-5) [<sup><i><b>g</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-6) [<sup><i><b>h</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-7) [<sup><i><b>i</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-8) [<sup><i><b>j</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DLhistory_4-9) [Schmidhuber, Juergen](https://en.wikipedia.org/wiki/Juergen_Schmidhuber "Juergen Schmidhuber") (2022). "Annotated History of Modern AI and Deep Learning". [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[2212.11279](https://arxiv.org/abs/2212.11279) \[[cs.NE](https://arxiv.org/archive/cs.NE)\].
5.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-lin1970_5-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-lin1970_5-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-lin1970_5-2) [Linnainmaa, Seppo](https://en.wikipedia.org/wiki/Seppo_Linnainmaa "Seppo Linnainmaa") (1970). _The representation of the cumulative rounding error of an algorithm as a Taylor expansion of the local rounding errors_ (Masters) (in Finnish). University of Helsinki. pp. 6–7.
6.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-lin1976_6-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-lin1976_6-1) [Linnainmaa, Seppo](https://en.wikipedia.org/wiki/Seppo_Linnainmaa "Seppo Linnainmaa") (1976). "Taylor expansion of the accumulated rounding error". _BIT Numerical Mathematics_. **16** (2): 146–160. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/bf01931367](https://doi.org/10.1007%2Fbf01931367). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [122357351](https://api.semanticscholar.org/CorpusID:122357351).
7.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-grie2012_7-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-grie2012_7-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-grie2012_7-2) Griewank, Andreas (2012). "Who Invented the Reverse Mode of Differentiation?". _Optimization Stories_. Documenta Matematica, Extra Volume ISMP. pp. 389–400. [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [15568746](https://api.semanticscholar.org/CorpusID:15568746).
8.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-grie2008_8-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-grie2008_8-1) Griewank, Andreas; [Walther, Andrea](https://en.wikipedia.org/wiki/Andrea_Walther "Andrea Walther") (2008). [_Evaluating Derivatives: Principles and Techniques of Algorithmic Differentiation, Second Edition_](https://books.google.com/books?id=xoiiLaRxcbEC). SIAM. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-0-89871-776-1](https://en.wikipedia.org/wiki/Special:BookSources/978-0-89871-776-1 "Special:BookSources/978-0-89871-776-1").
9.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-schmidhuber2015_9-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-schmidhuber2015_9-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-schmidhuber2015_9-2) [<sup><i><b>d</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-schmidhuber2015_9-3) [Schmidhuber, Jürgen](https://en.wikipedia.org/wiki/J%C3%BCrgen_Schmidhuber "Jürgen Schmidhuber") (2015). "Deep learning in neural networks: An overview". _Neural Networks_. **61**: 85–117. [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[1404.7828](https://arxiv.org/abs/1404.7828). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/j.neunet.2014.09.003](https://doi.org/10.1016%2Fj.neunet.2014.09.003). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [25462637](https://pubmed.ncbi.nlm.nih.gov/25462637). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [11715509](https://api.semanticscholar.org/CorpusID:11715509).
10.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-scholarpedia2015_10-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-scholarpedia2015_10-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-scholarpedia2015_10-2) [Schmidhuber, Jürgen](https://en.wikipedia.org/wiki/J%C3%BCrgen_Schmidhuber "Jürgen Schmidhuber") (2015). ["Deep Learning"](https://doi.org/10.4249%2Fscholarpedia.32832). _Scholarpedia_. **10** (11): 32832. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2015SchpJ..1032832S](https://ui.adsabs.harvard.edu/abs/2015SchpJ..1032832S). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.4249/scholarpedia.32832](https://doi.org/10.4249%2Fscholarpedia.32832).
11.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DL-reverse-mode_11-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-DL-reverse-mode_11-1) [Goodfellow, Bengio & Courville (2016](https://en.wikipedia.org/wiki/Backpropagation#CITEREFGoodfellowBengioCourville2016), p. [217](https://www.deeplearningbook.org/contents/mlp.html#pf36)–218), "The back-propagation algorithm described here is only one approach to automatic differentiation. It is a special case of a broader class of techniques called _reverse mode accumulation_."
12.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-12 "Jump up")** [Rosenblatt, Frank](https://en.wikipedia.org/wiki/Frank_Rosenblatt "Frank Rosenblatt") (1962). _Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms Cornell Aeronautical Laboratory. Report no. VG-1196-G-8 Report (Cornell Aeronautical Laboratory)_. Spartan. pp. Page XIII Table of contents, Page 292 "13.3 Back-Propagating Error Correction Procedures", Page 301 "figure 39 BACK-PROPAGATING ERROR-CORRECTION EXPERIMENTS".
13.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-kelley1960_13-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-kelley1960_13-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-kelley1960_13-2) [<sup><i><b>d</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-kelley1960_13-3) [Kelley, Henry J.](https://en.wikipedia.org/wiki/Henry_J._Kelley "Henry J. Kelley") (1960). "Gradient theory of optimal flight paths". _ARS Journal_. **30** (10): 947–954. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.2514/8.5282](https://doi.org/10.2514%2F8.5282).
14.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-bryson1961_14-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-bryson1961_14-1) Bryson, Arthur E. (1962). "A gradient method for optimizing multi-stage allocation processes". _Proceedings of the Harvard Univ. Symposium on digital computers and their applications, 3–6 April 1961_. Cambridge: Harvard University Press. [OCLC](https://en.wikipedia.org/wiki/OCLC_(identifier) "OCLC (identifier)") [498866871](https://www.worldcat.org/oclc/498866871).
15.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-FOOTNOTEGoodfellowBengioCourville2016[httpswwwdeeplearningbookorgcontentsmlphtmlpf33_214]_15-0 "Jump up")** [Goodfellow, Bengio & Courville 2016](https://en.wikipedia.org/wiki/Backpropagation#CITEREFGoodfellowBengioCourville2016), p. [214](https://www.deeplearningbook.org/contents/mlp.html#pf33), "This table-filling strategy is sometimes called _dynamic programming_."
16.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-robbins1951_16-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-robbins1951_16-1) [Robbins, H.](https://en.wikipedia.org/wiki/Herbert_Robbins "Herbert Robbins"); Monro, S. (1951). ["A Stochastic Approximation Method"](https://doi.org/10.1214%2Faoms%2F1177729586). _The Annals of Mathematical Statistics_. **22** (3): 400. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1214/aoms/1177729586](https://doi.org/10.1214%2Faoms%2F1177729586).
17.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-17 "Jump up")** [Goodfellow, Bengio & Courville 2016](https://en.wikipedia.org/wiki/Backpropagation#CITEREFGoodfellowBengioCourville2016), p. [200](https://www.deeplearningbook.org/contents/mlp.html#pf25), "The term back-propagation is often misunderstood as meaning the whole learning algorithm for multilayer neural networks. Backpropagation refers only to the method for computing the gradient, while other algorithms, such as stochastic gradient descent, is used to perform learning using this gradient."
18.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-learning-representations_18-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-learning-representations_18-1) Rumelhart; Hinton; Williams (1986). ["Learning representations by back-propagating errors"](http://www.cs.toronto.edu/~hinton/absps/naturebp.pdf) (PDF). _Nature_. **323** (6088): 533–536. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[1986Natur.323..533R](https://ui.adsabs.harvard.edu/abs/1986Natur.323..533R). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1038/323533a0](https://doi.org/10.1038%2F323533a0). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [205001834](https://api.semanticscholar.org/CorpusID:205001834).
19.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-21 "Jump up")** Ramachandran, Prajit; Zoph, Barret; Le, Quoc V. (2017-10-27). "Searching for Activation Functions". [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[1710.05941](https://arxiv.org/abs/1710.05941) \[[cs.NE](https://arxiv.org/archive/cs.NE)\].
20.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-22 "Jump up")** Misra, Diganta (2019-08-23). "Mish: A Self Regularized Non-Monotonic Activation Function". [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[1908.08681](https://arxiv.org/abs/1908.08681) \[[cs.LG](https://arxiv.org/archive/cs.LG)\].
21.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-RumelhartHintonWilliams1986a_27-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-RumelhartHintonWilliams1986a_27-1) [Rumelhart, David E.](https://en.wikipedia.org/wiki/David_E._Rumelhart "David E. Rumelhart"); [Hinton, Geoffrey E.](https://en.wikipedia.org/wiki/Geoffrey_E._Hinton "Geoffrey E. Hinton"); [Williams, Ronald J.](https://en.wikipedia.org/wiki/Ronald_J._Williams "Ronald J. Williams") (1986a). "Learning representations by back-propagating errors". _Nature_. **323** (6088): 533–536. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[1986Natur.323..533R](https://ui.adsabs.harvard.edu/abs/1986Natur.323..533R). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1038/323533a0](https://doi.org/10.1038%2F323533a0). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [205001834](https://api.semanticscholar.org/CorpusID:205001834).
22.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-Tan2018_30-0 "Jump up")** Tan, Hong Hui; Lim, King Han (2019). ["Review of second-order optimization techniques in artificial neural networks backpropagation"](https://doi.org/10.1088%2F1757-899X%2F495%2F1%2F012003). _IOP Conference Series: Materials Science and Engineering_. **495** (1): 012003. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2019MS&E..495a2003T](https://ui.adsabs.harvard.edu/abs/2019MS&E..495a2003T). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1088/1757-899X/495/1/012003](https://doi.org/10.1088%2F1757-899X%2F495%2F1%2F012003). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [208124487](https://api.semanticscholar.org/CorpusID:208124487).
23.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-Wiliamowski2010_31-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-Wiliamowski2010_31-1) Wiliamowski, Bogdan; Yu, Hao (June 2010). ["Improved Computation for Levenberg–Marquardt Training"](https://www.eng.auburn.edu/~wilambm/pap/2010/Improved%20Computation%20for%20LM%20Training.pdf) (PDF). _IEEE Transactions on Neural Networks and Learning Systems_. **21** (6).
24.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-Martens2020_32-0 "Jump up")** Martens, James (August 2020). "New Insights and Perspectives on the Natural Gradient Method". _Journal of Machine Learning Research_ (21). [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[1412.1193](https://arxiv.org/abs/1412.1193).
25.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-33 "Jump up")** [Nielsen (2015)](https://en.wikipedia.org/wiki/Backpropagation#CITEREFNielsen2015), "\[W\]hat assumptions do we need to make about our cost function ... in order that backpropagation can be applied? The first assumption we need is that the cost function can be written as an average ... over cost functions ... for individual training examples ... The second assumption we make about the cost is that it can be written as a function of the outputs from the neural network ..."
26.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-34 "Jump up")** LeCun, Yann; Bengio, Yoshua; Hinton, Geoffrey (2015). "Deep learning". _Nature_. **521** (7553): 436–444. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2015Natur.521..436L](https://ui.adsabs.harvard.edu/abs/2015Natur.521..436L). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1038/nature14539](https://doi.org/10.1038%2Fnature14539). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [26017442](https://pubmed.ncbi.nlm.nih.gov/26017442). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [3074096](https://api.semanticscholar.org/CorpusID:3074096).
27.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-35 "Jump up")** Buckland, Matt; Collins, Mark (2002). _AI Techniques for Game Programming_. Boston: Premier Press. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [1-931841-08-X](https://en.wikipedia.org/wiki/Special:BookSources/1-931841-08-X "Special:BookSources/1-931841-08-X").
28.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-36 "Jump up")** Rodríguez, Omar Hernández; López Fernández, Jorge M. (2010). ["A Semiotic Reflection on the Didactics of the Chain Rule"](https://scholarworks.umt.edu/tme/vol7/iss2/10/). _The Mathematics Enthusiast_. **7** (2): 321–332. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.54870/1551-3440.1191](https://doi.org/10.54870%2F1551-3440.1191). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [29739148](https://api.semanticscholar.org/CorpusID:29739148). Retrieved 2019-08-04.
29.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-37 "Jump up")** [Rosenblatt, Frank](https://en.wikipedia.org/wiki/Frank_Rosenblatt "Frank Rosenblatt") (1962). _Principles of Neurodynamics_. Spartan, New York.
30.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-Amari1967_38-0 "Jump up")** [Amari, Shun'ichi](https://en.wikipedia.org/wiki/Shun%27ichi_Amari "Shun'ichi Amari") (1967). "A theory of adaptive pattern classifier". _IEEE Transactions_. **EC** (16): 279–307.
31.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-werbos1982_39-0 "Jump up")** [Werbos, Paul](https://en.wikipedia.org/wiki/Paul_Werbos "Paul Werbos") (1982). ["Applications of advances in nonlinear sensitivity analysis"](http://werbos.com/Neural/SensitivityIFIPSeptember1981.pdf) (PDF). _System modeling and optimization_. Springer. pp. 762–770. [Archived](https://web.archive.org/web/20160414055503/http://werbos.com/Neural/SensitivityIFIPSeptember1981.pdf) (PDF) from the original on 14 April 2016. Retrieved 2 July 2017.
32.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-werbos1974_40-0 "Jump up")** Werbos, Paul J. (1994). _The Roots of Backpropagation : From Ordered Derivatives to Neural Networks and Political Forecasting_. New York: John Wiley & Sons. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [0-471-59897-6](https://en.wikipedia.org/wiki/Special:BookSources/0-471-59897-6 "Special:BookSources/0-471-59897-6").
33.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-RumelhartHintonWilliams1986b_41-0 "Jump up")** [Rumelhart, David E.](https://en.wikipedia.org/wiki/David_E._Rumelhart "David E. Rumelhart"); [Hinton, Geoffrey E.](https://en.wikipedia.org/wiki/Geoffrey_E._Hinton "Geoffrey E. Hinton"); [Williams, Ronald J.](https://en.wikipedia.org/wiki/Ronald_J._Williams "Ronald J. Williams") (1986b). ["8. Learning Internal Representations by Error Propagation"](https://archive.org/details/paralleldistribu00rume). In [Rumelhart, David E.](https://en.wikipedia.org/wiki/David_E._Rumelhart "David E. Rumelhart"); [McClelland, James L.](https://en.wikipedia.org/wiki/James_McClelland_(psychologist) "James McClelland (psychologist)") (eds.). _Parallel Distributed Processing : Explorations in the Microstructure of Cognition_. Vol. 1 : Foundations. Cambridge: MIT Press. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [0-262-18120-7](https://en.wikipedia.org/wiki/Special:BookSources/0-262-18120-7 "Special:BookSources/0-262-18120-7").
34.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-42 "Jump up")** Alpaydin, Ethem (2010). [_Introduction to Machine Learning_](https://books.google.com/books?id=4j9GAQAAIAAJ). MIT Press. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-0-262-01243-0](https://en.wikipedia.org/wiki/Special:BookSources/978-0-262-01243-0 "Special:BookSources/978-0-262-01243-0").
35.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-43 "Jump up")** Dreyfus, Stuart (1962). ["The numerical solution of variational problems"](https://doi.org/10.1016%2F0022-247x%2862%2990004-5). _Journal of Mathematical Analysis and Applications_. **5** (1): 30–45. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/0022-247x(62)90004-5](https://doi.org/10.1016%2F0022-247x%2862%2990004-5).
36.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-dreyfus1990_44-0 "Jump up")** [Dreyfus, Stuart E.](https://en.wikipedia.org/wiki/Stuart_Dreyfus "Stuart Dreyfus") (1990). "Artificial Neural Networks, Back Propagation, and the Kelley-Bryson Gradient Procedure". _Journal of Guidance, Control, and Dynamics_. **13** (5): 926–928. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[1990JGCD...13..926D](https://ui.adsabs.harvard.edu/abs/1990JGCD...13..926D). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.2514/3.25422](https://doi.org/10.2514%2F3.25422).
37.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-45 "Jump up")** Mizutani, Eiji; Dreyfus, Stuart; Nishio, Kenichi (July 2000). ["On derivation of MLP backpropagation from the Kelley-Bryson optimal-control gradient formula and its application"](https://coeieor.wpengine.com/wp-content/uploads/2019/03/ijcnn2k.pdf) (PDF). Proceedings of the IEEE International Joint Conference on Neural Networks.
38.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-dreyfus1973_46-0 "Jump up")** [Dreyfus, Stuart](https://en.wikipedia.org/wiki/Stuart_Dreyfus "Stuart Dreyfus") (1973). "The computational solution of optimal control problems with time lag". _IEEE Transactions on Automatic Control_. **18** (4): 383–385. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/tac.1973.1100330](https://doi.org/10.1109%2Ftac.1973.1100330).
39.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-47 "Jump up")** Parker, D.B. (1985). "Learning Logic". Center for Computational Research in Economics and Management Science. Cambridge MA: Massachusetts Institute of Technology.
40.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-:0_48-0 "Jump up")** Hertz, John (1991). _Introduction to the theory of neural computation_. Krogh, Anders., Palmer, Richard G. Redwood City, Calif.: Addison-Wesley. p. 8. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [0-201-50395-6](https://en.wikipedia.org/wiki/Special:BookSources/0-201-50395-6 "Special:BookSources/0-201-50395-6"). [OCLC](https://en.wikipedia.org/wiki/OCLC_(identifier) "OCLC (identifier)") [21522159](https://www.worldcat.org/oclc/21522159).
41.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-49 "Jump up")** Wan, Eric A. (1994). "Time Series Prediction by Using a Connectionist Network with Internal Delay Lines". In [Weigend, Andreas S.](https://en.wikipedia.org/wiki/Andreas_Weigend "Andreas Weigend"); [Gershenfeld, Neil A.](https://en.wikipedia.org/wiki/Neil_Gershenfeld "Neil Gershenfeld") (eds.). _Time Series Prediction : Forecasting the Future and Understanding the Past_. Proceedings of the NATO Advanced Research Workshop on Comparative Time Series Analysis. Vol. 15. Reading: Addison-Wesley. pp. 195–217. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [0-201-62601-2](https://en.wikipedia.org/wiki/Special:BookSources/0-201-62601-2 "Special:BookSources/0-201-62601-2"). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [12652643](https://api.semanticscholar.org/CorpusID:12652643).
42.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-50 "Jump up")** Chang, Franklin; Dell, Gary S.; Bock, Kathryn (2006). "Becoming syntactic". _Psychological Review_. **113** (2): 234–272. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1037/0033-295x.113.2.234](https://doi.org/10.1037%2F0033-295x.113.2.234). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [16637761](https://pubmed.ncbi.nlm.nih.gov/16637761).
43.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-51 "Jump up")** Janciauskas, Marius; Chang, Franklin (2018). ["Input and Age-Dependent Variation in Second Language Learning: A Connectionist Account"](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6001481). _Cognitive Science_. **42** (Suppl Suppl 2): 519–554. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1111/cogs.12519](https://doi.org/10.1111%2Fcogs.12519). [PMC](https://en.wikipedia.org/wiki/PMC_(identifier) "PMC (identifier)") [6001481](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6001481). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [28744901](https://pubmed.ncbi.nlm.nih.gov/28744901).
44.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-52 "Jump up")** Fitz, Hartmut; Chang, Franklin (2019). "Language ERPs reflect learning through prediction error propagation". _Cognitive Psychology_. **111**: 15–52. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/j.cogpsych.2019.03.002](https://doi.org/10.1016%2Fj.cogpsych.2019.03.002). [hdl](https://en.wikipedia.org/wiki/Hdl_(identifier) "Hdl (identifier)"):[21.11116/0000-0003-474D-8](https://hdl.handle.net/21.11116%2F0000-0003-474D-8). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [30921626](https://pubmed.ncbi.nlm.nih.gov/30921626). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [85501792](https://api.semanticscholar.org/CorpusID:85501792).
45.  **[^](https://en.wikipedia.org/wiki/Backpropagation#cite_ref-53 "Jump up")** ["Photonic Chips Curb AI Training's Energy Appetite - IEEE Spectrum"](https://spectrum.ieee.org/backpropagation-optical-ai). _spectrum.ieee.org_. Retrieved 2023-05-25.

## Further reading\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=18 "Edit section: Further reading")\]

-   [Goodfellow, Ian](https://en.wikipedia.org/wiki/Ian_Goodfellow "Ian Goodfellow"); [Bengio, Yoshua](https://en.wikipedia.org/wiki/Yoshua_Bengio "Yoshua Bengio"); Courville, Aaron (2016). ["6.5 Back-Propagation and Other Differentiation Algorithms"](https://www.deeplearningbook.org/contents/mlp.html#pf25). [_Deep Learning_](http://www.deeplearningbook.org/). MIT Press. pp. 200–220. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [9780262035613](https://en.wikipedia.org/wiki/Special:BookSources/9780262035613 "Special:BookSources/9780262035613").
-   [Nielsen, Michael A.](https://en.wikipedia.org/wiki/Michael_Nielsen "Michael Nielsen") (2015). ["How the backpropagation algorithm works"](http://neuralnetworksanddeeplearning.com/chap2.html). [_Neural Networks and Deep Learning_](http://neuralnetworksanddeeplearning.com/). Determination Press.
-   McCaffrey, James (October 2012). ["Neural Network Back-Propagation for Programmers"](https://docs.microsoft.com/en-us/archive/msdn-magazine/2012/october/test-run-neural-network-back-propagation-for-programmers). _[MSDN Magazine](https://en.wikipedia.org/wiki/MSDN_Magazine "MSDN Magazine")_.
-   [Rojas, Raúl](https://en.wikipedia.org/wiki/Ra%C3%BAl_Rojas "Raúl Rojas") (1996). ["The Backpropagation Algorithm"](https://page.mi.fu-berlin.de/rojas/neural/chapter/K7.pdf) (PDF). _Neural Networks : A Systematic Introduction_. Berlin: Springer. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [3-540-60505-3](https://en.wikipedia.org/wiki/Special:BookSources/3-540-60505-3 "Special:BookSources/3-540-60505-3").

## External links\[[edit](https://en.wikipedia.org/w/index.php?title=Backpropagation&action=edit&section=19 "Edit section: External links")\]

-   [Backpropagation neural network tutorial at the Wikiversity](https://en.wikiversity.org/wiki/Learning_and_Neural_Networks "wikiversity:Learning and Neural Networks")
-   Bernacki, Mariusz; Włodarczyk, Przemysław (2004). ["Principles of training multi-layer neural network using backpropagation"](http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html).
-   [Karpathy, Andrej](https://en.wikipedia.org/wiki/Andrej_Karpathy "Andrej Karpathy") (2016). ["Lecture 4: Backpropagation, Neural Networks 1"](https://www.youtube.com/watch?v=i94OvYb6noo&list=PLkt2uSq6rBVctENoVBg1TpCC7OQi31AlC&index=4). _CS231n_. Stanford University. [Archived](https://ghostarchive.org/varchive/youtube/20211212/i94OvYb6noo) from the original on 2021-12-12 – via [YouTube](https://en.wikipedia.org/wiki/YouTube "YouTube").
-   ["What is Backpropagation Really Doing?"](https://www.youtube.com/watch?v=Ilg3gGewQ5U&list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&index=3). _3Blue1Brown_. November 3, 2017. [Archived](https://ghostarchive.org/varchive/youtube/20211212/Ilg3gGewQ5U) from the original on 2021-12-12 – via [YouTube](https://en.wikipedia.org/wiki/YouTube "YouTube").
-   Putta, Sudeep Raja (2022). ["Yet Another Derivation of Backpropagation in Matrix Form"](https://sudeepraja.github.io/BackpropAdjoints/).